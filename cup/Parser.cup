package Example;

import java_cup.runtime.*;
import Example.Parser.Expr;

parser code {:
    public static abstract class Expr {
		public abstract int eval();
		public abstract Location right();
		public abstract Location left();
    }

    public static void main(String args[]) throws Exception {
		ComplexSymbolFactory sf = new ComplexSymbolFactory();
		if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
		else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
    }

    public void syntax_error(Symbol sym){ 
	// Mute legacy Error Printing
    	System.out.println("Error: "+sym );
    }
:}

terminal TRUE, FALSE, REAL, SEMICOLON, COLON, PAR_C, PAR_A, MUSTACHE_A, MUSTACHE_C, CORCH_A, CORCH_C, ASIG, SUMASIG, RESASIG, IGUAL, SUM, RES, MENOR, MAYOR, MUL, DIV, PORCENT, MAY_IGUAL, MEN_IGUAL, AND, OR, NO_IGUAL, NEGAC, INC, DEC, ID, BOOL, BREAK, CLASS, CONTINUE, ELSE, FLOAT, FOR, IF, INTEGER, RETURN, VOID, WHILE, EXTERN, PUNTO,ALPHA,GUION_BAJO;
terminal Integer NUM;

non terminal expr_list, expr_part,program,class_decl,field_decl,field_declarations,method_declarations,method_decl,body,block,type,statement,asign_op,bin_op,arith_op,rel_op,eq_op,cond_op,literal,bool_literal,expr,int_literal, param_decl, param_id, param_expr,location,method_call,float_literal,alpha_num;

precedence left PAR_A, PAR_C;
precedence left MUSTACHE_A, MUSTACHE_C;
precedence left CORCH_A, CORCH_C;
precedence left ELSE, NEGAC;
precedence nonassoc  MENOR, MAYOR, MEN_IGUAL, MAY_IGUAL;
precedence left OR, AND, PORCENT, IGUAL, NO_IGUAL;
precedence left SUM, RES;
precedence left MUL, DIV;
 
program ::= class_decl | class_decl program 
		| error:e SEMICOLON:s {: parser.report_error("Syntax error in input from "+exleft +" to "+sxright,e); :};

class_decl ::= CLASS ID MUSTACHE_A field_declarations method_declarations MUSTACHE_C
		|CLASS ID MUSTACHE_A  method_declarations MUSTACHE_C
		|CLASS ID MUSTACHE_A field_declarations MUSTACHE_C
		|CLASS ID MUSTACHE_A  MUSTACHE_C
		;
field_decl ::=  type MUSTACHE_A ID 
		| ID CORCH_A int_literal CORCH_C MUSTACHE_C SEMICOLON
		;		
field_declarations ::= field_decl
			|field_declarations SEMICOLON field_decl
			;

method_decl ::= type ID PAR_A PAR_C body
			| type ID PAR_A param_decl PAR_C body
			;

method_declarations ::= method_decl
		|method_declarations method_decl
		;

param_decl ::= type ID
	     | param_decl COLON type ID
	     ;
body ::= block
	| EXTERN SEMICOLON
	;
block ::= MUSTACHE_A field_declarations statement MUSTACHE_C
	| MUSTACHE_A field_declarations MUSTACHE_C
	| MUSTACHE_A statement MUSTACHE_C
	| MUSTACHE_A MUSTACHE_C
	;
type ::= INTEGER
	|FLOAT
	|BOOL
	|ID
	|VOID
	;
statement ::= location asign_op expr SEMICOLON
	  |method_call SEMICOLON
	  |IF PAR_A expr PAR_C statement
	  |IF PAR_A expr PAR_C statement ELSE statement
	  |FOR ID IGUAL expr COLON expr statement
	  |WHILE expr statement
	  |RETURN expr SEMICOLON
	  |RETURN SEMICOLON
	  |BREAK SEMICOLON
	  |CONTINUE SEMICOLON
	  |SEMICOLON
	  |block
	  ;

asign_op ::= ASIG
	  |SUMASIG
	  |RESASIG
	  ;

method_call ::= ID PAR_A param_expr PAR_C
		|ID PAR_A PAR_C
		|ID param_id PAR_A param_expr PAR_C
		|ID param_id PAR_A PAR_C  
		;

param_expr ::= expr
	    | param_expr COLON expr
	    ;

param_id ::= PUNTO ID
	  |param_id PUNTO ID
	  ;

location ::= ID 
	|ID param_id
	|ID CORCH_A expr CORCH_C
	|ID param_id CORCH_A expr CORCH_C
	;
expr ::= location
	| method_call
	| literal
	| expr bin_op expr
	| RES expr
	| NEGAC expr
	| PAR_A expr PAR_C
	;
bin_op ::= arith_op
	| rel_op
	| eq_op
	| cond_op
	;
arith_op ::= SUM
	  | RES
	  | MUL
	  | DIV
	  | PORCENT
	;
rel_op ::= MENOR
	| MAYOR
	| MAY_IGUAL
	| MEN_IGUAL
	;
eq_op ::= IGUAL
	| NO_IGUAL
	;
cond_op ::= AND
	| OR
	;
literal ::= int_literal
	| float_literal
	| bool_literal
	;

alpha_num ::= ALPHA
	   | NUM
	   | GUION_BAJO
	   ;

bool_literal ::= TRUE | FALSE ;

int_literal ::= NUM | int_literal NUM ;

float_literal ::= REAL ;


