package Compi;

import java_cup.runtime.*;
import Compi.Parser.Expr;

parser code {:
    public static abstract class Expr {
		public abstract int eval();
		public abstract Location right();
		public abstract Location left();
    }

    public static void main(String args[]) throws Exception {
		ComplexSymbolFactory sf = new ComplexSymbolFactory();
		if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
		else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
    }

    public void syntax_error(Symbol sym){ 
	// Mute legacy Error Printing
		System.out.println("Syntax error" );
    	System.out.println("Error: "+sym );
    }
:}

terminal Boolean TRUE, FALSE;
terminal float REAL;
terminal String SEMICOLON, COLON, PAR_C, PAR_A, MUSTACHE_A, MUSTACHE_C, CORCH_A, CORCH_C, ASIG, SUMASIG, RESASIG, IGUAL, SUM, RES, MENOR, MAYOR, MUL, DIV, PORCENT, MAY_IGUAL, MEN_IGUAL, AND, OR, NO_IGUAL, NEGAC, ID, BOOL, BREAK, CLASS, CONTINUE, ELSE, FLOAT, FOR, IF, INTEGER, RETURN, VOID, WHILE, EXTERN, PUNTO;
terminal Integer NUM;

non terminal Program program;
non terminal ClassDecl class_decl;
non terminal LinkedList<FieldDecl> field_declarations;
non terminal FieldDecl field_decl;
non terminal MethodDeclarations method_declarations;
non terminal MethodDecl method_decl;
non terminal Body body;
non terminal Block block;
non terminal BlField bl_field;
non terminal BlStatement bl_statement;
non terminal Type type;
non terminal Statement statement;
non terminal Asign_op asign_op;
non terminal Bin_op bin_op;
non terminal Arith_op arith_op;
non terminal Rel_op rel_op;
non terminal Eq_op eq_op;
non terminal Cond_op cond_op;
non terminal Literal literal;
non terminal Bool_literal bool_literal;
non terminal Expr expr;
non terminal Int_literal int_literal;
non terminal Param_decl param_decl;
non terminal Param_id param_id;
non terminal Param_expr param_expr;
non terminal Location location;
non terminal Method_call method_call;
non terminal Float_literal float_literal;
non terminal list_names, name ;

precedence left OR, AND;
precedence nonassoc  MENOR, MAYOR, MEN_IGUAL, MAY_IGUAL, IGUAL, NO_IGUAL;
precedence left SUM, RES;
precedence left MUL, DIV, PORCENT;
precedence left ELSE, NEGAC;
 
program ::= class_decl:c {:RESULT = new Program(c);:}
         | class_decl:c program:p {:p.addClass(c); RESULT=p;:} 
         ;

class_decl ::= CLASS:cl ID:name MUSTACHE_A field_declarations:f method_declarations:m MUSTACHE_C {:RESULT = new ClassDecl(name,f,m,clxleft.getLine());:}
		    |CLASS:cl ID:name MUSTACHE_A  method_declarations:m MUSTACHE_C {:RESULT = new ClassDecl(name,m,clxleft.getLine());:}
		    |CLASS:cl ID:name MUSTACHE_A field_declarations:f MUSTACHE_C {:RESULT = new ClassDecl(name,f,clxleft.getLine());:}
		    |CLASS:cl ID:name MUSTACHE_A  MUSTACHE_C {:RESULT = new ClassDecl(name,clxleft.getLine());:}
		    ;
			
field_decl ::=  type:t	list_names SEMICOLON
			;

list_names ::= name
			| list_names COLON name
			;

name ::= ID
		| ID CORCH_A int_literal CORCH_C
		;

field_declarations ::= field_decl 
					| field_declarations field_decl 
			        ;

method_decl ::= type ID PAR_A PAR_C body
			 | type ID PAR_A param_decl PAR_C body
			 ;

method_declarations ::= method_decl
		|method_declarations method_decl
		;

param_decl ::= type ID
	     | param_decl COLON type ID
	     ;
body ::= block
	| EXTERN SEMICOLON
	;
block ::= MUSTACHE_A bl_field bl_statement MUSTACHE_C
	| MUSTACHE_A bl_field MUSTACHE_C
	| MUSTACHE_A bl_statement MUSTACHE_C
	| MUSTACHE_A MUSTACHE_C
	;

bl_field ::= field_decl
	| bl_field field_decl 
	;

bl_statement ::= statement
	| bl_statement statement
	;	

type ::= INTEGER
	|FLOAT
	|BOOL
	|ID
	|VOID
	;
statement ::= location asign_op expr SEMICOLON
	  |method_call SEMICOLON
	  |IF PAR_A expr PAR_C statement
	  |IF PAR_A expr PAR_C statement ELSE statement
	  |FOR ID ASIG expr COLON expr statement
	  |WHILE expr statement
	  |RETURN expr SEMICOLON
	  |RETURN SEMICOLON
	  |BREAK SEMICOLON
	  |CONTINUE SEMICOLON
	  |SEMICOLON
	  |block
	  ;

asign_op ::= ASIG
	  |SUMASIG
	  |RESASIG
	  ;

method_call ::= ID PAR_A param_expr PAR_C
		|ID PAR_A PAR_C
		|ID param_id PAR_A param_expr PAR_C
		|ID param_id PAR_A PAR_C  
		;

param_expr ::= expr
	    | param_expr COLON expr
	    ;

param_id ::= PUNTO ID
	  |param_id PUNTO ID
	  ;

location ::= ID:i {:System.out.println(i.left);:} 
	|ID param_id
	|ID CORCH_A expr CORCH_C
	|ID param_id CORCH_A expr CORCH_C
	;
expr ::= location
	| method_call
	| literal
	| expr bin_op expr
	| RES expr
	| NEGAC expr
	| PAR_A expr PAR_C
	;
bin_op ::= arith_op
	| rel_op
	| eq_op
	| cond_op
	;
arith_op ::= SUM
	  | RES
	  | MUL
	  | DIV
	  | PORCENT
	;
rel_op ::= MENOR
	| MAYOR
	| MAY_IGUAL
	| MEN_IGUAL
	;
eq_op ::= IGUAL
	| NO_IGUAL
	;
cond_op ::= AND
	| OR
	;
literal ::= int_literal
	| float_literal
	| bool_literal
	;

bool_literal ::= TRUE | FALSE ;

int_literal ::= NUM | int_literal NUM ;

float_literal ::= REAL ;



